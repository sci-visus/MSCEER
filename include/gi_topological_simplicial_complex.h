/*
*
* Copyright (C) 2018 Attila Gyulassy <jediati@sci.utah.edu>
* All rights reserved.
*
* This software may be modified and distributed under the terms
* of the BSD license.  See the LICENSE file for details.
*/

#ifndef TOPOLOGICAL_SIMPLICIAL_COMPLEX_H
#define TOPOLOGICAL_SIMPLICIAL_COMPLEX_H


#define NULLID -1

#include <map>
#include <unordered_map>
#include <set>
#include "gi_basic_types.h"
#include "gi_vectors.h"
#include "gi_regular_grid.h"
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <iostream>
#include <sstream>

namespace GInt {


	// TopologicalRegularGrid3D is a specialized class to work with the connectivity of a
	// regular 3d grid - with quantities derived from an input regular 3d grid. 
	// This class handles no storage on its own - it simply
	// provides a mechanism for iterating over cells, iterating over facets and cofacets of cells
	// and answering questions about a cell, such as its dimension, whether or not it sits on a 
	// boundary, what its coordinates are, etc. 
	//
	// This class uses a cell index numbering to make neighborhood queries fast - simply reduces
	// to adding a pre-computed offset to the current cell id. E.g. For a nonperiodic grid with X*Y*Z values,
	// the indices generated by this class uses a grid of size (2X-1)*(2Y-1)*(2Z-1), basically
	// representing every cell (vertex, edge, quad, hex) with a unique id, such that facets/cofacets
	// of a cell id can be computed by simply adding an offset to the  cell id. 

	// NOTE: we use unsigned long longs for the axes, since we do not want any arithmetic we do with them
	// to be accidentally truncated to 32-bit integers.

	class TopologicalSimplicialComplex2d {
    public:
            void display() const {

            }


	protected:

		INDEX_TYPE m_num_cells;			// total number of cells (vertices, mEdgesLIArray, quads, hex)
		INDEX_TYPE m_num_dcells[4];		// store the number of vertices, mEdgesLIArray, quads, hexahedra in our mesh


		struct s_vertex {
			INDEX_TYPE mFirstEdge_LI;
			Vec3d position;
			s_vertex() {
				mFirstEdge_LI = NULLID;
			}
		};

		struct s_edge {
			INDEX_TYPE mVertsLIArray[2];
			INDEX_TYPE mNextEdges_LI[2];
			INDEX_TYPE mFirstTriangle_LI;
			s_edge() {
				mVertsLIArray[0] = NULLID;
				mVertsLIArray[1] = NULLID;
				mNextEdges_LI[0] = NULLID;
				mNextEdges_LI[1] = NULLID;
				mFirstTriangle_LI = NULLID;
			}
		};

		struct s_triangle {
			INDEX_TYPE mEdgesLIArray[3];
			INDEX_TYPE mNextTri_LI[3];
			s_triangle() {
				for (int i = 0; i < 3; i++) {
					mEdgesLIArray[i] = NULLID;
					mNextTri_LI[i] = NULLID;
				}
			}
		};
		struct idpos{
			INDEX_TYPE id;
			Vec3d pos;
			idpos(INDEX_TYPE i, Vec3d p) : id(i), pos(p){}
		};
		struct triple {
			INDEX_TYPE v1, v2, v3;
			triple(INDEX_TYPE a, INDEX_TYPE b, INDEX_TYPE c) {
				v1 = a; v2 = b; v3 = c;
			}
			triple() {}
		};
		typedef std::pair<INDEX_TYPE, INDEX_TYPE> epair;

		std::vector<s_vertex> mVerticesArray;
		std::vector<s_edge> mEdgesLIArray;
		std::vector<s_triangle> mTrisLIArray;
		
		epair make_pair(INDEX_TYPE a, INDEX_TYPE b) {
			if (a > b) return epair(b, a);
			return epair(a,b);
		}

		void vertex_add_edge(INDEX_TYPE vid_LI, INDEX_TYPE eid_LI) {
			s_vertex& v = mVerticesArray[vid_LI];
			s_edge& e = mEdgesLIArray[eid_LI];

			if (e.mVertsLIArray[0] == vid_LI) {
				e.mNextEdges_LI[0] = v.mFirstEdge_LI;
				v.mFirstEdge_LI = eid_LI;
			}
			else {
				e.mNextEdges_LI[1] = v.mFirstEdge_LI;
				v.mFirstEdge_LI = eid_LI;
			}
		}

		void edge_add_triangle(INDEX_TYPE eid_LI, INDEX_TYPE tid_LI) {
			s_edge& e = mEdgesLIArray[eid_LI];
			s_triangle& t = mTrisLIArray[tid_LI];
			if (t.mEdgesLIArray[0] == eid_LI) {
				t.mNextTri_LI[0] = e.mFirstTriangle_LI;
				e.mFirstTriangle_LI = tid_LI;
			}
			else if (t.mEdgesLIArray[1] == eid_LI) {
				t.mNextTri_LI[1] = e.mFirstTriangle_LI;
				e.mFirstTriangle_LI = tid_LI;
			}
			else {
				t.mNextTri_LI[2] = e.mFirstTriangle_LI;
				e.mFirstTriangle_LI = tid_LI;
			}
		}

		void build_complex(std::vector<idpos>& tIdPosVerts, std::vector<triple>& tris) {
			// add in all the vertices
			std::unordered_map<INDEX_TYPE, INDEX_TYPE> vmap;
			INDEX_TYPE vnewind = 0;
			for (auto v : tIdPosVerts) {
				vmap[v.id] = vnewind++;
				s_vertex nv;
				nv.position = v.pos;
				mVerticesArray.push_back(nv);
			}

			// add in missing triangle and edge (no connections yet)
			// for each triangle add it and each edge
			INDEX_TYPE enewind = 0;
			INDEX_TYPE tnewind = 0;
			std::map<epair, INDEX_TYPE> edge_map;
			for (auto t : tris) {

				s_triangle tri;
				INDEX_TYPE trid = tnewind++;
				epair es[3];
				es[0] = make_pair(vmap[t.v1], vmap[t.v2]);
				es[1] = make_pair(vmap[t.v2], vmap[t.v3]);
				es[2] = make_pair(vmap[t.v3], vmap[t.v1]);

				for (int i = 0; i < 3;i++) {
					epair& e = es[i];
					INDEX_TYPE eid;
					if (edge_map.count(e) == 0) {
						// create the edge
						eid = enewind++;
						edge_map[e] = eid;
						s_edge ne;
						// set first edge of triangle
						ne.mVertsLIArray[0] = e.first;
						ne.mVertsLIArray[1] = e.second;
						mEdgesLIArray.push_back(ne);
					}
					else {
						eid = edge_map[e];
					}
					tri.mEdgesLIArray[i] = eid;
				}

				mTrisLIArray.push_back(tri);
			}

			for (int eid = 0; eid < (int)mEdgesLIArray.size(); eid++) {
				s_edge& e = mEdgesLIArray[eid];
				vertex_add_edge(e.mVertsLIArray[0], eid);
				vertex_add_edge(e.mVertsLIArray[1], eid);
			}
			for (int tid = 0; tid < (int)mTrisLIArray.size(); tid++) {
				s_triangle& t = mTrisLIArray[tid];
				for (int j = 0; j < 3; j++) {
					edge_add_triangle(t.mEdgesLIArray[j], tid);
				}
			}
			mDCellIndexOffsets[0] = 0;
			mDCellIndexOffsets[1] = mVerticesArray.size();
			mDCellIndexOffsets[2] = mDCellIndexOffsets[1] + mEdgesLIArray.size();
			m_num_cells = mDCellIndexOffsets[2] + mTrisLIArray.size();
			m_num_dcells[0] = mDCellIndexOffsets[1];
			m_num_dcells[1] = mEdgesLIArray.size();
			m_num_dcells[2] = mTrisLIArray.size();
	
			printf("num cells: [ %d, %d, %d ]\n", m_num_dcells[0], m_num_dcells[1], m_num_dcells[2]);
			this->SetBoundaryFlags();
		}

		std::vector<idpos> t_vids;
		std::vector<triple> t_tris;
		Vec3d mMinBoundingBox;
		Vec3d mMaxBoundingBox;

		void add_vertex(INDEX_TYPE id, Vec3d position) {
			for (int i = 0; i < 3; i++) {
				if (position[i] < mMinBoundingBox[i]) mMinBoundingBox[i] = position[i];
				if (position[i] > mMaxBoundingBox[i]) mMaxBoundingBox[i] = position[i];
			}
			t_vids.push_back(idpos(id, position));
		}
		void add_triangle(INDEX_TYPE a, INDEX_TYPE b, INDEX_TYPE c) {
			t_tris.push_back(triple(a, b, c));
		}
		INDEX_TYPE mDCellIndexOffsets[3];

		const inline INDEX_TYPE cellid_to_edgeid(INDEX_TYPE cellid) const {
			return cellid - mDCellIndexOffsets[1];
		}
		const inline INDEX_TYPE cellid_to_triid(INDEX_TYPE cellid) const {
			return cellid - mDCellIndexOffsets[2];
		}

		const inline INDEX_TYPE triid_to_cellid(INDEX_TYPE triid) const {
			return triid + mDCellIndexOffsets[2];
		}
		const inline INDEX_TYPE edgeid_to_cellid(INDEX_TYPE edgeid) const {
			return edgeid + mDCellIndexOffsets[1];
		}
	public:



		class AllCellsIterator {
		protected:
			INDEX_TYPE mPos_GI;
			const INDEX_TYPE mStart_GI;
			const INDEX_TYPE mEnd_GI;

		public:
			AllCellsIterator(TopologicalSimplicialComplex2d* m) :
				mPos_GI(0), mStart_GI(0), mEnd_GI(m->numCells()) {}

			AllCellsIterator(TopologicalSimplicialComplex2d* m, INDEX_TYPE start, INDEX_TYPE end) :
				mPos_GI(start), mStart_GI(start), mEnd_GI(end) {}

			void begin() {
				mPos_GI = mStart_GI;
			}
			void advance() {
				mPos_GI++;
			}
			bool valid() const {
				return mPos_GI < mEnd_GI;
			}
			INDEX_TYPE value() const {
				return mPos_GI;
			}
		};

		class DCellsIterator {
		protected:
			INDEX_TYPE mPos_GI;
			INDEX_TYPE mStart_GI;
			INDEX_TYPE mEnd_GI;
			TopologicalSimplicialComplex2d* const mMesh;
			const DIM_TYPE mDim;
		public:
			DCellsIterator(TopologicalSimplicialComplex2d* mesh, DIM_TYPE dim) :
				mDim(dim), mMesh(mesh) {
				if (dim == 0) {
					mStart_GI = mPos_GI = 0;
					mEnd_GI = mesh->mVerticesArray.size();
				}
				else if (dim == 1) {
					mStart_GI = mPos_GI = mesh->mDCellIndexOffsets[1];
					mEnd_GI = mesh->mDCellIndexOffsets[2];
				}
				else {
					mStart_GI = mPos_GI = mesh->mDCellIndexOffsets[2];
					mEnd_GI = mesh->m_num_cells;
				}
			}

			void begin() {
				mPos_GI = mStart_GI;
			}
			void advance() {
				mPos_GI++;
			}
			bool valid() const {
				return mPos_GI < mEnd_GI;
			}
			INDEX_TYPE value() const {
				return mPos_GI;
			}
		};

		//// also needs boundary!!! WILL USE IF rather than virutal function
		class FacetsIterator {
		protected:
			INDEX_TYPE mOffsetToAddToLI;
			const TopologicalSimplicialComplex2d* const mMesh;		
			const INDEX_TYPE* mFacetLIArrayPointer;
			DIM_TYPE mNumFacets;
			INDEX_TYPE mCurrId;
		public:
            FacetsIterator(const TopologicalSimplicialComplex2d *const mesh) : mMesh(mesh) {}

			void begin(INDEX_TYPE const &cellid_GI) {			
				mCurrId = 0; // on zeroth cell of facet array
				mNumFacets = mMesh->dimension(cellid_GI) + 1;
				if (mNumFacets <= 1) {
					mNumFacets = 0;
					return;
				}
				if (mNumFacets > 1) mOffsetToAddToLI = mMesh->mDCellIndexOffsets[mNumFacets - 2];
				switch (mNumFacets) {
				case 1:
					// vertices;
					mFacetLIArrayPointer = NULL;
					mNumFacets = 0;
					break;
				case 2:
					mFacetLIArrayPointer = mMesh->mEdgesLIArray[mMesh->cellid_to_edgeid(cellid_GI)].mVertsLIArray;
					break;
				case 3:
					mFacetLIArrayPointer = mMesh->mTrisLIArray[mMesh->cellid_to_triid(cellid_GI)].mEdgesLIArray;
					break;
				} // get integer coordinates
				
			}
			void advance() {
				mCurrId++;
			}
			bool valid() const {
				return mCurrId < mNumFacets;
			}
			INDEX_TYPE value() const {
				return mFacetLIArrayPointer[mCurrId] + mOffsetToAddToLI;
			}
		};

		//// also needs boundary!!! WILL USE IF rather than virutal function
		class CofacetsIterator {
		protected:
			const TopologicalSimplicialComplex2d* const mMesh;
			DIM_TYPE mDim;
			INDEX_TYPE mOffsetToAddToLI;
			INDEX_TYPE mBaseID_LI;
			INDEX_TYPE mCurrentCell_LI;
			bool mUseEdge;

			INDEX_TYPE nextEdgeLI() {
				const s_edge& e = mMesh->mEdgesLIArray[mCurrentCell_LI];
				if (e.mVertsLIArray[0] == mBaseID_LI) {
					return e.mNextEdges_LI[0];
				}
				else {
					return e.mNextEdges_LI[1];
				}
			}

			INDEX_TYPE nextTriLI() {
				const s_triangle&  t = mMesh->mTrisLIArray[mCurrentCell_LI];
				for (int i = 0; i < 3; i++) {
					if (t.mEdgesLIArray[i] == mBaseID_LI) return t.mNextTri_LI[i];
				}
				printf("SHOULD NEVER GET EHRE IN COFACET ITERATOR\n");
				return NULLID;
			}

		public:
            CofacetsIterator(const TopologicalSimplicialComplex2d *const m) : mMesh(m) {}

			void begin(INDEX_TYPE const &cellid_GI) {
				mDim = mMesh->dimension(cellid_GI);
				if (mDim < 2) {
					mOffsetToAddToLI = mMesh->mDCellIndexOffsets[mDim + 1];
				}
				else {
					mCurrentCell_LI = NULLID;
					return;
				}
				mUseEdge = (mDim == 0);
				if (mUseEdge) {
					mBaseID_LI = cellid_GI; // base id was vertex so global cellid = local cell id
					mCurrentCell_LI = mMesh->mVerticesArray[mBaseID_LI].mFirstEdge_LI;
				}
				else {
					mBaseID_LI = mMesh->cellid_to_edgeid(cellid_GI); // base id was edge, so get its id
					mCurrentCell_LI = mMesh->mEdgesLIArray[mBaseID_LI].mFirstTriangle_LI;
				}
			}
			void advance() {
				if (mUseEdge) {
					mCurrentCell_LI = nextEdgeLI();
				}
				else {
					mCurrentCell_LI = nextTriLI();
				}
			}
			bool valid() const {
				return mCurrentCell_LI != NULLID;
			}
			INDEX_TYPE value() const {
				return mCurrentCell_LI + mOffsetToAddToLI;
			}
		};


		//// also needs boundary!!! WILL USE IF rather than virutal function
		class AdjacentCellsIterator {
		protected:


			const TopologicalSimplicialComplex2d* const mMesh;
			DIM_TYPE mDim;
			std::set<INDEX_TYPE> mCellSetGI;
			std::set<INDEX_TYPE>::iterator mCellSetGIIter;

		public:
			AdjacentCellsIterator(const TopologicalSimplicialComplex2d *const mesh) : mMesh(mesh) {}

			// this encodes both orientation AND the position in a number <= 72 (i.e. 8 * 9)
			void begin(INDEX_TYPE const &cellid_GI) {
				mDim = mMesh->dimension(cellid_GI);
				mCellSetGI.clear();
				if (mDim == 0) {
					TopologicalSimplicialComplex2d::CofacetsIterator edge_iter(mMesh);
					for (edge_iter.begin(cellid_GI); edge_iter.valid(); edge_iter.advance()) {
						INDEX_TYPE edge_GI = edge_iter.value();
						TopologicalSimplicialComplex2d::CofacetsIterator tri_iter(mMesh);
						for (tri_iter.begin(edge_GI); tri_iter.valid(); tri_iter.advance()) {
							mCellSetGI.insert(tri_iter.value());
						}
						mCellSetGI.insert(edge_GI);
					}
				}
				else if (mDim == 1) {
					TopologicalSimplicialComplex2d::FacetsIterator verts_iter(mMesh);
					for (verts_iter.begin(cellid_GI); verts_iter.valid(); verts_iter.advance()) {
						mCellSetGI.insert(verts_iter.value());
					}
					TopologicalSimplicialComplex2d::CofacetsIterator tris_iter(mMesh);
					for (tris_iter.begin(cellid_GI); tris_iter.valid(); tris_iter.advance()) {
						mCellSetGI.insert(tris_iter.value());
					}

				}
				else {
					TopologicalSimplicialComplex2d::FacetsIterator edges_iter(mMesh);
					for (edges_iter.begin(cellid_GI); edges_iter.valid(); edges_iter.advance()) {
						INDEX_TYPE edge_GI = edges_iter.value();
						TopologicalSimplicialComplex2d::FacetsIterator vert_iter(mMesh);
						for (vert_iter.begin(edge_GI); vert_iter.valid(); vert_iter.advance()) {
							mCellSetGI.insert(vert_iter.value());
						}
						mCellSetGI.insert(edge_GI);
					}
				}
				mCellSetGIIter = mCellSetGI.begin();

			}

			void advance() {
				mCellSetGIIter++;
			}

			bool valid() const {
				return mCellSetGIIter != mCellSetGI.end();
			}

			INDEX_TYPE value() const {
				return *mCellSetGIIter;
			}

			INDEX_TYPE value(int pos) {
				auto it = mCellSetGI.begin();
				for (; pos > 0; pos--) it++;
				return *it;
			}
		};

		//// also needs boundary!!! WILL USE IF rather than virutal function
		class CellVerticesIterator {

		protected:
			const TopologicalSimplicialComplex2d* const mMesh;
			DIM_TYPE mDim;
			INDEX_TYPE mVertArrayGI[3];
			int mNumCells;
			int mCurrCell;



		public:
			CellVerticesIterator(const TopologicalSimplicialComplex2d *const mesh) : mMesh(mesh) {}

			void begin(INDEX_TYPE const &cellid_GI) {
				mDim = mMesh->dimension(cellid_GI);
				mNumCells = mDim + 1;

				if (mDim == 0) {
					mVertArrayGI[0] = cellid_GI;
				}
				else if (mDim == 1) {
					mVertArrayGI[0] = mMesh->mEdgesLIArray[mMesh->cellid_to_edgeid(cellid_GI)].mVertsLIArray[0];
					mVertArrayGI[1] = mMesh->mEdgesLIArray[mMesh->cellid_to_edgeid(cellid_GI)].mVertsLIArray[1];
				}
				else {
					const s_triangle& t = mMesh->mTrisLIArray[mMesh->cellid_to_triid(cellid_GI)];
					const s_edge& e = mMesh->mEdgesLIArray[t.mEdgesLIArray[0]];
					mVertArrayGI[0] = e.mVertsLIArray[0];
					mVertArrayGI[1] = e.mVertsLIArray[1];
					const s_edge& eo = mMesh->mEdgesLIArray[t.mEdgesLIArray[1]];
					if (eo.mVertsLIArray[0] == mVertArrayGI[0] || eo.mVertsLIArray[0] == mVertArrayGI[1]) {
						mVertArrayGI[2] = eo.mVertsLIArray[1];
					}
					else {
						mVertArrayGI[2] = eo.mVertsLIArray[0];
					}
				}
				mCurrCell = 0;


			}
			void advance() {
				mCurrCell++;
			}

			bool valid() const {
				return mCurrCell < mNumCells;
			}

			INDEX_TYPE value() const {
				return mVertArrayGI[mCurrCell];
			}

            // added by Harsh to directly get a certain vertex
            // fixed for periodic boundary on 01.18.2017
            INDEX_TYPE value(int pos) const {
				return mVertArrayGI[pos];
            }

			DIM_TYPE offset(INDEX_TYPE id) {
				if (value() == id) return mCurrCell;
				for (int i = 0; i < mNumCells; i++) {
					if (mVertArrayGI[i] == id) return i;
				}
				return -1;
			}
		};

		int CountCoFacets(INDEX_TYPE cellid_GI) {
			int counter = 0;
			TopologicalSimplicialComplex2d::CofacetsIterator cfit(this);
			for (cfit.begin(cellid_GI); cfit.valid(); cfit.advance()) {
				counter++;
			}
			return counter;
		}

		std::set<INDEX_TYPE> mBoundaryCells;
		void SetBoundaryFlags() {
			mBoundaryCells.clear();

			TopologicalSimplicialComplex2d::DCellsIterator edges(this, 1);
			for (edges.begin(); edges.valid(); edges.advance()) {
				INDEX_TYPE edge_GI = edges.value();
				int numtris = CountCoFacets(edge_GI);

				if (numtris == 1) {
					TopologicalSimplicialComplex2d::FacetsIterator verts_iter(this);
					for (verts_iter.begin(edge_GI); verts_iter.valid(); verts_iter.advance()) {
						mBoundaryCells.insert(verts_iter.value());
					}
					mBoundaryCells.insert(edge_GI);
				}
			}
		}


	public:

		TopologicalSimplicialComplex2d() {}


		virtual  ~TopologicalSimplicialComplex2d() {
			printf("delete: TopologicalSimplicialComplex2d \n");
		}

		// these return values from 0-27 - an offset computed by the "27" version 
		// MUST be turned into an id with the matching "27" version
		BYTE_TYPE CompressVertexOffsetToByte(INDEX_TYPE base_cell, INDEX_TYPE other_cell, CellVerticesIterator& cell_vertices_iter) const {
			return cell_vertices_iter.offset(other_cell);
		}
		INDEX_TYPE UncompressByteToVertexOffset(INDEX_TYPE base_cell, BYTE_TYPE direction) const {
			CellVerticesIterator vit(this);
			vit.begin(base_cell);
			return vit.value(direction);
		}

		INDEX_TYPE numCells() const {
			return m_num_cells;
		}

		INDEX_TYPE numCells(DIM_TYPE dim) const {
			return m_num_dcells[dim];
		}

		DIM_TYPE maxDim() const {
			return 2;
		}


		BOUNDARY_TYPE boundaryValue(INDEX_TYPE cellid) const {
            return mBoundaryCells.count(cellid);
		}


		DIM_TYPE dimension(const INDEX_TYPE& cellid) const {
			if (cellid < mDCellIndexOffsets[1]) return 0;
			if (cellid < mDCellIndexOffsets[2]) return 1;
			return 2;
		}


		Vec3d BoundingBoxMin() { return mMinBoundingBox; }
		Vec3d BoundingBoxMax() { return mMaxBoundingBox; }

		void centroid(INDEX_TYPE cellid, Vec3d &coords) const {
			TopologicalSimplicialComplex2d::CellVerticesIterator cit(this);
			coords = Vec3d(0, 0, 0);
			int tmp = 0;
			for (cit.begin(cellid); cit.valid(); cit.advance()) {
				coords += mVerticesArray[cit.value()].position;
				tmp++;
			}
			coords *= 1.0/tmp;
		}

		//INDEX_TYPE Extent(DIM_TYPE i) const {
		//return mExtentList[i*2];
		//}

		
		INDEX_TYPE VertexNumberFromCellID(const INDEX_TYPE cellid) const {
			return cellid;
		}
		INDEX_TYPE CellIDFromVertexNumber(const INDEX_TYPE vertex_number) const {
			return vertex_number;
		}
		

		bool LoadFromObj(const char* filename) {
			mVerticesArray.clear();
			mEdgesLIArray.clear();
			mTrisLIArray.clear();
			t_tris.clear();
			t_vids.clear();

			printf("about to read...\n");
			// get number of mVertsLIArray and number of faces
			int numberOfVerts = 0;
			int numberOfMaxDimCells = 0;
			char firstchar;
			char buffer[256];
			char* bufferp;
			FILE* f = fopen(filename, "r");
			while (!feof(f)) {
				fscanf(f, "%[^\n]\n", buffer);
				//printf("%s\n",  buffer);
				firstchar = buffer[0];
				bufferp = &(buffer[1]);
				if (firstchar == 'v') {
					
					// obj indices start at 1
					numberOfVerts++;

					// read number of floats
					std::vector<float> v;

					std::string Numbers(bufferp);
					// Build an istream that holds the input string
					std::istringstream iss(Numbers);

					// Iterate over the istream, using >> to grab floats
					// and push_back to store them in the vector
					std::copy(std::istream_iterator<float>(iss),
						std::istream_iterator<float>(),
						std::back_inserter(v));

					Vec3d pos(0,0,0);
					for (int i = 0; i < 3 && i < (int)v.size(); i++) pos[i] = v[i];
					if (t_vids.size() == 0) {
						mMinBoundingBox = pos;
						mMaxBoundingBox = pos;
					}
					this->add_vertex(numberOfVerts, pos);
				}
				if (firstchar == 'f') {

					//printf("%s", bufferp);
					numberOfMaxDimCells++;
					triple t;
					sscanf(bufferp, "%llu %llu %llu\n", &(t.v1), &(t.v2), &(t.v3));
					add_triangle(t.v1, t.v2, t.v3);

				}
			}
			fclose(f);
			printf("counted %d mVertsLIArray, %d faces\n", numberOfVerts,
				numberOfMaxDimCells);
			printf("building complex\n");
			this->build_complex(t_vids, t_tris);

			printf("found %d boundary cells\n", mBoundaryCells.size());
			return true;

		}

        //int num_faces(INDEX_TYPE cellid) const {

        //    int cnt = 0;
        //    FacetsIterator fiter (this);
        //    for(fiter.begin (cellid); fiter.valid (); fiter.advance ()) {
        //        cnt++;
        //    }
        //    return cnt;
        //}

        //// check if a is a coface of b
        //bool is_cofacet_of(INDEX_TYPE a, INDEX_TYPE b)  const {

        //    CofacetsIterator fiter (this);
        //    for(fiter.begin (b); fiter.valid (); fiter.advance ()) {
        //        if(a == fiter.value ()) {
        //            return true;
        //        }
        //    }
        //    return false;
        //}
	};

	class SimplicialComplexCoordinateFunction {
	protected:
		TopologicalSimplicialComplex2d* mMesh;
		int mCoord;
		float mScale;
	public:
		SimplicialComplexCoordinateFunction(TopologicalSimplicialComplex2d* mesh, int axis) : mMesh(mesh), mCoord(axis), mScale(1.0f) {}

		void SetScale(float val) { mScale = val; }
		float value(INDEX_TYPE vid) const {
			Vec3d coords;
			mMesh->centroid(vid, coords);
			return coords[mCoord] * mScale;
		}

		bool IsGreater(INDEX_TYPE a, INDEX_TYPE b) const {
			//if (mMesh->dimension(a) != 0) printf("ERROR IN ISGREATER: dim a is big!\n");
			//if (mMesh->dimension(b) != 0) printf("ERROR IN ISGREATER: dim b is big!\n");
			float va = value(a);
			float vb = value(b);
			if (va > vb) return true;
			if (vb > va) return false;
			return a > b;
		}
	};

	class SimplicialComplexRotatedCoordinateFunction {
	protected:
		TopologicalSimplicialComplex2d* mMesh;
		int mCoord;
		int mRAxis;
		float mAngle;
		float mCosAngle;
		float mSinAngle;
	public:
		SimplicialComplexRotatedCoordinateFunction(TopologicalSimplicialComplex2d* mesh, int axis, int raxis) : mMesh(mesh), mCoord(axis), mRAxis(raxis) {
			SetAngle(0);
		}

		void SetAngle(float val) { 
			mAngle = val; 
			mCosAngle = cos(val);
			mSinAngle = sin(val);
		}
		float value(INDEX_TYPE vid) const {
			Vec3d coords;
			mMesh->centroid(vid, coords);

			if (mRAxis == 0) {
				float newx = mCosAngle * coords[1] - mSinAngle * coords[2];
				float newy = mSinAngle * coords[1] + mCosAngle * coords[2];
				coords[1] = newx;
				coords[2] = newy;
			}
			else if (mRAxis == 1) {
				float newx = mCosAngle * coords[0] - mSinAngle * coords[2];
				float newy = mSinAngle * coords[0] + mCosAngle * coords[2];
				coords[0] = newx;
				coords[2] = newy;
			}
			else if (mRAxis == 2) {
				float newx = mCosAngle * coords[0] - mSinAngle * coords[1];
				float newy = mSinAngle * coords[0] + mCosAngle * coords[1];
				coords[0] = newx;
				coords[1] = newy;
			}
			 

			

			return coords[mCoord];
		}

		bool IsGreater(INDEX_TYPE a, INDEX_TYPE b) const {
			//if (mMesh->dimension(a) != 0) printf("ERROR IN ISGREATER: dim a is big!\n");
			//if (mMesh->dimension(b) != 0) printf("ERROR IN ISGREATER: dim b is big!\n");
			float va = value(a);
			float vb = value(b);
			if (va > vb) return true;
			if (vb > va) return false;
			return a > b;
		}
	};

	template < class FuncType >
	class NegatingFunction {
	protected:
		FuncType* mF;
	public:
		NegatingFunction(FuncType* f) : mF(f) {}
		bool IsGreater(INDEX_TYPE a, INDEX_TYPE b) const {
			return mF->IsGreater(b, a);
		}
		float value(INDEX_TYPE vid) const {
			return -1 * mF->value(vid);
		}
	};

}




#endif
